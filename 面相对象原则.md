## 单一职责原则（SRP：Single responsibility principle）

就一个类而言，应该仅有一个引起它变化的原因； 通俗的说，即一个类只负责一项职责

分析：
1. 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力；这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。
2. 软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。
3. 如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。

## 开放-封闭原则（OCP：Open Closed Principle）
是说软件实体（类、模块、函数等等）应该可以扩展，但是不可以修改；  
特征1：对于扩展是开放的（Open for extension）；     
特征2：对于更改是封闭的（Closed for modification）。     
分析：
1. 在我们最初编写代码时，假设变化不会发生；当变化发生时，我们就创建抽象来隔离以后发生的同类变化。
2. 面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。
3. 开闭原则是面向对象设计的核心，遵循这个原则会带来一系列好处，可扩展、可复用、可维护、灵活。对频繁变化的部分作出抽象，封装变化。

## 依赖倒转原则
A.高层模块不应该依赖低层模块。两个都应该依赖抽象      
B.抽象不应该依赖细节，细节应该依赖抽象    
分析：
1. 就是要针对接口编程，不要对实现编程     
> 无论主板、CUP、内存都是在针对接口设计的，如果针对实现来设计，内存就要应对到具体的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬；
2. 高层模块不应该依赖低层模块，两者都应该依赖其抽象又如何理解呢？这个问题也可以这么问：为什么要叫倒置(倒转)呢？      
在面向过程的开发中，为了使用常用的代码可以复用，一般都会把这些常用的代码写成许许多多函数的程序库，这样我们做新项目的时候，就去调用这些函数就可以了。   
 例如：我们做的项目大多要访问数据库，所以我们就把数据库的代码写成了函数，每次做新项目时就去调用这些函数，这也就是高层依赖于低层模块了。    
如果我们的高层模块和低层模块都依赖于抽象，具体一点就是依赖于接口或抽象类，只要接口够稳定，那么任何一个的更改都不用担心其他受到影响了。

 

## 里氏代换原则
子类型必须能够替换掉它们的父类型。      
换句话说，一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而其它察觉不出父类对象和子类对象的区别。
也就是说，在软件里面，把父类都替换成它都替换成它的子类，程序的行为没有变化。
分析：
1. 正因为有这个原则，使得继承复用成为了可能，
只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。
2. 正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。
3. 里氏代换原则是（开闭原则、依赖倒置原则的前提）

![](2019-04-24-11-54-24.png)       

---

![](2019-04-24-11-55-06.png)


4. 依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，
即使程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。

## 迪米特法则（LKP：Least Knowledge Principle，又叫最少知识原则）
如果两个类不必彼此直接通信，那么这两个类就不应当直接的相互作用；如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
分析：
1. 在类的结构设计上，每一个类都应当尽量降低成员的访问权限；
2. 其根本思想是强调了类之间的松耦合；
3. 类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及。

## 合成/聚合复用原则

![](2019-04-24-10-53-03.png)
合成（Composition）和聚合（Aggregation）都是关联的特殊种类；    
聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；    
合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样     


尽量使用合成/聚合,尽量不要使用类继承    
优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上；    
这样类和类继承层次会保持较小规模，并且不太可能增长为不可能控制的庞然大物。    
继承是一种强耦合的结构。子类随父类改变而改变，一定要在是‘is-a’的关系在考虑使用。      
> 建议阅读：桥接模式


## （追加）接口隔离原则
  客户端不应该依赖它不需要的接口；
  一个类对另一个类的依赖应该建立在最小的接口上。

  **分析**     
一个类对另一个类的依赖应该建立在最小的接口上；     
一个接口代表一个角色，不应该将不同的角色都交给一个接口，因为这样可能会形成一个臃肿的大接口；     
不应该强迫客户依赖它们从来不用的方法。     